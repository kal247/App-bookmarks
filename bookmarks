#!/usr/bin/env perl
#
# bookmarks - Export browser bookmarks as plain text.
#
# bookmarks is a Perl script to export browser bookmarks as plain text.
# When called without arguments, it attempts to extract bookmarks from the 
# default location of all supported browsers :
#
# - Safari (Mac) : ~/Library/Safari/Bookmarks.plist
# - Firefox (Mac) : ~/Library/Application Support/Firefox/Profiles/*.default/places.sqlite
# - Firefox (Linux) : ~/.mozilla/firefox/*.default/places.sqlite
# - Firefox (Windows) : %APPDATA%\Mozilla\Firefox\Profiles\*.default\places.sqlite
# - Internet Explorer (Windows) : %USERPROFILE%\Favorites\*
#
# Otherwise, it processes files supplied as arguments sequentially, according
# to the file extension (or name).
#
# The fields <title>, <url> and <description> are retrieved (when existing) and
# are available for exporting (in the desired format), by default : <title> <url>
#
# TODO :
# - with firefox open (locked DB), script does not exit (good or bad?)
# - autoflush STDOUT/STDERR
# - glob() not portable
# - remove option -a ?
# - text files support
# - markdown files support
# - relies on external tool plutil + dirty regex
# - space after fields if empty
# - true recursive search for IE Favorites subfolders

# - dont't die if places.sqlite doesn't exists

##### pas d'erreur si manque Config::Tiny


#
# 2019.09.27 v0.15 jul : added internet explorer support
# 2019.08.13 v0.14 jul : added firefox support, output format
# 2019.07.11 v0.13 jul : use 5.010, better doc
# 2019.01.14 v0.12 jul : fixed case sensitive regex
# 2018.09.21 v0.11 jul : added arg and -a
# 2018.09.01 v0.10 jul : created

use 5.010;
use strict;
use warnings;
use utf8;
use Getopt::Std;
use File::Basename;
use DBI;
use Config::Any;
use File::Find;

our $VERSION 	= '0.16';
my $program		= basename($0);
my $usage   	= <<EOF;

Usage: $program [-hVda] [-f format] [file ...]

    -h, --help      help
    -V, --version   version
    -d              debug
    -a              export all (same as option -f tud)
	-f format       any combination of letters t,u,d as title/url/description (default : tu)
EOF

# options

my %options = ();
getopts("hVdaf:q:s:r:", \%options) or die $usage;

my $help        = $options{h} // 0;
my $version     = $options{V} // 0;
my $debug       = $options{d} // 0;
my $all         = $options{a} // 0;
my $format      = $options{f} // "tu";
my $quote       = $options{q} // " ";   # TODO
my $fs          = $options{s} // " ";	# TODO
my $rs          = $options{r} // "\n";	# TODO

die $usage if $help;
die $VERSION . "\n" if $version;

# option -a
$format = "tud" if $all;

# option -f
my %dispatch = (
'tu'	=> sub { my $t = shift // ""; my $u= shift // ""; my $d = shift // ""; print "$t$fs$u$rs"; },
#'tu'	=> sub { my $t = shift // ""; my $u= shift // ""; my $d = shift // ""; say join $fs, ($t,$u); },
#'tu'	=> sub { my $t = shift // ""; my $u= shift // ""; my $d = shift // ""; foreach ($t,$u) { print "$_$fs" if defined $_;} say ""; },
'tud'	=> sub { my $t = shift // ""; my $u= shift // ""; my $d = shift // ""; print "$t$fs$u$fs$d$rs"; },
'tdu'	=> sub { my $t = shift // ""; my $u= shift // ""; my $d = shift // ""; print "$t$fs$d$fs$u$rs"; },
'ud'	=> sub { my $t = shift // ""; my $u= shift // ""; my $d = shift // ""; print "$u$fs$d$rs"; },
'u'		=> sub { my $t = shift // ""; my $u= shift // ""; my $d = shift // ""; print "$u$rs"; },
'ut'	=> sub { my $t = shift // ""; my $u= shift // ""; my $d = shift // ""; print "$u$fs$t$rs"; },
'dut'	=> sub { my $t = shift // ""; my $u= shift // ""; my $d = shift // ""; print "$d$fs$u$fs$t$rs";  },
'du'	=> sub { my $t = shift // ""; my $u= shift // ""; my $d = shift // ""; print "$d$fs$u$rs";},
'dtu'	=> sub { my $t = shift // ""; my $u= shift // ""; my $d = shift // ""; print "$d$fs$t$fs$u$rs";}
);

# printer function
my $print_bookmark;

if ($dispatch{$format})
{
	$print_bookmark = $dispatch{$format};
}
else
{
	die "unknown format";
}

# set default files per os
if (!@ARGV)
{
	say $^O;

    # check os name
    if ($^O eq "darwin")
    {    
        # safari
        push @ARGV, glob('~/Library/Safari/Bookmarks.plist');
        # firefox
        push @ARGV, glob('~/Library/Application\ Support/Firefox/Profiles/*.default/places.sqlite');
    }
    elsif ($^O eq "linux")
    {
        # firefox
        push @ARGV, glob('~/.mozilla/firefox/*.default/places.sqlite');
    }
    elsif ($^O eq "MSWin32")
    {
        # firefox
        push @ARGV, $ENV{APPDATA} . '\Mozilla\Firefox\Profiles\*.default\places.sqlite';
		# internet explorer
        push @ARGV, $ENV{USERPROFILE} . '\Favorites';
		
		say $ARGV[0];
		say $ARGV[1];
		}
    else
    {
        die "unknown os, unable to set default files";
    }
}

###############
# SUBROUTINES #
###############

sub process_safari {

    my $plist = shift // "";
    warn "\$plist: $plist\n" if $debug;

    # validate plutil and plist
    my $res = `plutil $plist`;
    die "plutil failed : $res" if $res !~ /OK$/;

    # read plist as text
    my $text = `plutil -p $plist`;
    die "plutil failed on file $plist" if not $text;
    
    # split on ddd => {}
    my @pieces = split /\d+ => \{(.*?)\}\s+\d+ => \{/s, $text;
    
    # find bookmarks among pieces
    my @bookmarks = grep /URLString/, @pieces;
    
    # print
    foreach my $bm (@bookmarks)
    {
        my $title       = $1 if $bm =~ /"title" => "(.+)"/i;
        my $url         = $1 if $bm =~ /"URLString" => "(.+)"/i;
        my $description = $1 if $bm =~ /"PreviewText" => "(.+)"/i;
        
        $print_bookmark->($title, $url, $description);
    }
}

sub process_firefox {

    my $dbfile = shift // "";
    warn "\$dbfile: $dbfile\n" if $debug;
    
    my $dbh = DBI->connect("dbi:SQLite:dbname=$dbfile", # DSN: dbi, driver, database file
                           "",                          # no user
                           "",                          # no password
                           { RaiseError => 1, PrintError => 0, AutoCommit => 0 },  # RaiseError=die() PrintError=warn()
                           ) or die $DBI::errstr;

    # build sql statement
    my $sql =  "select b.title, p.url, k.keyword as description
                from moz_places p
                left join moz_origins o on o.id = p.origin_id
                left join moz_bookmarks b on b.fk = p.id
                left join moz_keywords k on k.place_id = p.id
                where o.prefix != 'place:'";
    warn "\$sql: $sql\n" if $debug;

    # prepare, execute and commit transaction
    eval
    {
        my $sth = $dbh->prepare($sql);
        $sth->execute();
        $dbh->commit;

        if ($sth)
        {
            while ($sth and my $hashref = $sth->fetchrow_hashref)
            {
                $print_bookmark->($hashref->{'title'}, $hashref->{'url'}, $hashref->{'description'});
            }
        }     
    };
    
    if ($@)
    {
        warn "transaction failed : $@";
        die  "unable to process file : $dbfile\n";
    }

    $dbh->disconnect;
}

sub process_iexplorer {
    
	my $favorites = shift // "";
    warn "\$favorites: $favorites\n" if $debug;

	# search in favorites and subfolders
	my @files;
	find( { wanted => sub { push @files, $_ }, no_chdir => 1 }, $favorites );

	foreach my $file (@files)
	{
		my @filepaths = ($file);

		# force load internet shortcuts .url as INI files
		my @plugins = ('Config::Any::INI');
		my $cfg = Config::Any->load_files( {files => \@filepaths, force_plugins => \@plugins} );
 
		for (@$cfg)
		{
			my ($filename, $config) = %$_;
			
			my $title	= substr(basename($filename), 0, -4); # chop ".url"
			my $url 	= $config->{'InternetShortcut'}->{'URL'} // "";

			$print_bookmark->($title, $url);
		}
	}
}


############
# RUN LOOP #
############

foreach my $arg (@ARGV)
{
    my $name = basename($arg);
    
	if    ($name =~ /\.plist$/)		{ process_safari($arg); }
	#elsif ($name =~ /\.sqlite$/)	{ process_firefox($arg); }
	elsif ($name =~ /Favorites$/)	{ process_iexplorer($arg); }
}

exit 1;
